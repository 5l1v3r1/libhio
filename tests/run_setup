#----------------------------------------------------------------------------
# run_setup - common setup for hio tests 
# Source this file from each test script.
#
# Env vars used for input:
#   HIO_BUILD - location of HIO build tree, defaults to $PWD/..
#
# BASH variables set that can be used by test script:
#        root - data root for test, created or emptied
#        size - gross size of IO, per rank t|s|m|l|x|y|z
#       ranks - number of MPI ranks
#    verbose_lev - xexec2 verbosity level
#   debug_lev - xexec2 debug level
#   HIO_TEST_ROOT - if not set, will be set to default data root string  
#
# BASH functions that can be called by the test script:
#   clean_roots - creates or empties out specified data roots
#           cmd - logs and runs a command
#           msg - logs a message
#         myrun - issues mpirun or aprun command with -n specified 
#
#----------------------------------------------------------------------------
synexit() {
  echo ""
  if [[ -n $* ]]; then echo $*; echo ""; fi
  echo "run_setup - common setup for hio tests"
  echo ""
  echo "  Syntax:"
  echo "    $0"
  echo "        [-s <size>]]"
  echo "        [-r <num_ranks>]"
  echo "        [-n <num_nodes>]"
  echo "        [-p <ppn>]"
  echo "        [-v <verbose_level>]"
  echo "        [-d <debug_level>]"
  echo "        [-b] [-c] [-a]"
  echo "        [-m <msub args>]"
  echo ""
  echo "  Options:"   
  echo "    -s <size>       Per rank run size t|s|m|l|x|y|z  (default s)"
  echo "    -r <num_ranks>  Number of MPI ranks.  Default is all allocated"
  echo "                    PEs or 2 on Mac OS"
  echo "    -n <num_nodes>  Number of nodes.  Default is all allocated nodes"
  echo "                    or 2 or 1 on Mac OS"
  echo "    -p <ppn>        PEs per node.  If specified with -n and -r, must agree"
  echo "    -v <verbose_lev>   Verbosity level for xexec2, default 1"
  echo "    -d <debug_lev>  Debug level for xexec2, default 0"
  echo "    -b              Submit batch job with these options"
  echo "    -c              Chain jobs - make this job dependant on previous job"
  echo "    -a              Clean dirs After running" 
  echo "    -m              Additional arguments for msub (use with -b)"
  echo ""
  echo "  Cornell Wright  cornell@lanl.gov"
  
  exit 8
}

#----------------------------------------------------------------------------
# Functions for run_setup and test scripts to use
#----------------------------------------------------------------------------
cmd() {
  echo "$host ---> $*"
  eval "$*"
  return $?         
}

msg() { 
  echo "$host $*" 
}

# Function to check max_rc and output a summary message
check_rc(){
  if [[ $max_rc > 0 ]]; then result="FAILURE"
  else result="SUCCESS"; fi
  jobend=`date "$datefmt"`
  echo "###############################################################################"
  echo "Start: $jobstart  End: $jobend  Test: $0 -s $size -n $nodes -r $ranks   RESULT: $result"
  echo "###############################################################################"
}

# Function to build run script and submit batch job if batch mode
batch_sub() {
  # Save DataWarp required capacity with 5% + 1GiB  overhead and rounded up to next GiB
  dw_cap="$(( (($1 * 21 / 20) + (1 * $cons_gi) + ($cons_gi - 1) ) / $cons_gi ))GiB"
  if [[ $batch -eq 1 ]]; then
    rundir="$PWD/run"
    if [[ ! -d $rundir ]]; then cmd "mkdir -p $rundir"; fi
    lastjob="$rundir/last_jobid"

    # Ensure unique job name
    jobname=`date +%Y%m%d.%H%M%S`
    jobsh="$rundir/job.$jobname.sh"
    while [[ -e $jobsh ]]; do
      msg "File $jobsh already exists, trying another"
      sleep 1
      jobname=`date +%Y%m%d.%H%M%S`
      jobsh="$rundir/job.$jobname.sh"
    done

    echo "#! /bin/bash" > $jobsh
    echo "#MSUB -l nodes=$nodes:ppn=$ppn" >> $jobsh
    echo "#MSUB -l walltime=8:00:00" >> $jobsh
    echo "#MSUB -o $rundir/job.$jobname.out -joe" >> $jobsh
    echo "#MSUB -d $PWD" >> $jobsh
    echo "#DW jobdw access_mode=striped type=scratch capacity=$dw_cap" >> $jobsh

    echo "echo \"\`date \"$datefmt\"\` Job $jobname start\"" >> $jobsh
    echo "echo \"\"" >> $jobsh
    echo "echo \"$jobsh:\"" >> $jobsh
    echo "cat $jobsh" >> $jobsh
    echo "echo \"\"" >> $jobsh

    afterparm=""
    if [[ $after -gt 0 ]]; then afterparm="-a"; fi
    echo "$0 -s $size $afterparm -v $verbose_lev -d $debug_lev" >> $jobsh

    echo "echo \"\`date \"$datefmt\"\` Job $jobname   end\"" >> $jobsh
    msg "run_setup: nodes/ranks/ppn: $nodes / $ranks / $ppn"

    mcmd="msub"
    if [[ -n $HIO_verbose ]]; then mcmd="$mcmd -v HIO_verbose"; fi
    if [[ -n $msub_arg ]]; then mcmd="$mcmd $msub_arg"; fi
    if [[ $chain -ne 0 ]]; then
      if [[ -r $lastjob ]]; then
        read lastjobid < $lastjob
        mcmd="$mcmd -l depend=$lastjobid"
      else
        msg "Last jobid file \"$lastjob\" not readable, ignoring chain option"
      fi
    fi
    mcmd="$mcmd $jobsh" 
    msg "run_setup: ---> $mcmd"
    msub_msg=`$mcmd`

    shopt -s extglob
    #jobid=${msub_msg##*([!0-9])}
    jobid=${msub_msg:1}

    echo "$jobid" > $lastjob
    msg "run_setup: job $jobname ID: $jobid submitted"
    exit
  fi
}

# This string contains the logic to check, empty or create a test data root
# directory.  It needs to be executed on a compute node via aprun for datawarp.
# It's also used for locally accessible directories for the sake of consistency.
clean_cmd="
  if [[ -z \$0 ]]; then
    echo \"run_setup: zero length test root name0\"
    exit
  fi
  if [ -e \$0 ]; then
    if [ -d \$0 ]; then
      if [ ! -w \$0 ]; then
        echo \"run_setup: Unable to write to test root \$0\"
        exit
      else
        echo \"---> rm -fR \$0/*\"
        rm -fR \$0/*
      fi
    else
      echo \"run_setup: Test root \$0 exists and is not a directory\"
      exit
    fi
  else
    echo \"---> mkdir -p \$0\"
    mkdir -p \$0
  fi
"

# Function to clean data roots, i.e., create or empty them out 
clean_roots() {
  allroots=${1-HIO_TEST_ROOTS}
  IFS=","; read -ra root <<< "$allroots"; unset IFS
  for r in "${root[@]}"; do
    shopt -s nocasematch
    if [[ "$r" == "dw" || "$r" == "datawarp" ]]; then
      clean=""
      if [[ -n $DW_JOB_STRIPED    ]]; then clean=$DW_JOB_STRIPED; fi
      if [[ -n $HIO_datawarp_root ]]; then clean=$HIO_datawarp_root; fi
      if [[ -n $clean ]]; then
        echo "Cleaning: \"$r\""
        echo "===> aprun bash -c \$clean_cmd $clean"
        aprun -n 1 -b bash -c "$clean_cmd" $clean
      fi
    elif [[ ${r:0:6} == "posix:" ]]; then
      echo "Cleaning: \"$r\""
      r=${r:6}
      # r=${r%"/"}
      # last=${r##*/}
      if [[ $r == ${r/test} ]]; then
        echo "Warning: skipping clean of non-test directory \"$r\""
      else
        bash -c "$clean_cmd" $r
      fi
    else 
      echo "Error: data root \"$r\" type not recognized."
      exit
    fi 
    shopt -u nocasematch
  done
}

# function to invoke mpi on various platforms - sets max_rc
myrun() {
  cmd "$mympicmd -n $ranks $*"
  rc=$?
  max_rc=$((rc > max_rc ? rc : max_rc)) 
  return $rc
}

#----------------------------------------------------------------------------
# Parse arguments and other common setup
#----------------------------------------------------------------------------
datefmt="+%Y-%m-%d %H:%M:%S"
jobstart=`date "$datefmt"`
host=`hostname -s`
max_rc=0
verbose_lev=1
debug_lev=0
batch=0
chain=0
after=0

size="s"
job_dir=""
# Platform specific defaults
if [[ ${OSTYPE:0:6} == "darwin" ]]; then
  mympicmd="mpirun"
else
  size="m"
  type aprun > /dev/null 2>&1
  if [[ $? -eq 0 ]]; then
    # aprun available - must be a Cray
    mympicmd="aprun"
    size="m"
    if [[ -n $PBS_JOBID ]]; then
      set | egrep "^PBS|^DW|^HOST|^HIO"
      job_dir="/${PBS_JOBID%%.*}"
    fi
    if [[ -n $PBS_NODEFILE ]]; then 
      echo ""
      cmd "cat $PBS_NODEFILE | sort | uniq | pr -t --columns 8"
    fi
    if [[ -n $DW_JOB_STRIPED ]]; then
      . $MODULESHOME/init/bash
      module load dws
      echo ""
      cmd "dwstat all"
    fi
  else
    # aprun not available - use mpirun
    mympicmd="mpirun"
    if [[ -n $SLURM_JOB_ID ]]; then
      set | egrep "^SLURM|^DW"
      job_dir="/SLURM_JOB_ID"
    fi
  fi
fi

args="$0 $*"
while getopts "hs:r:n:p:v:d:bcam:" optname; do
  case $optname in
    h ) synexit;;
    s ) size=$OPTARG;;
    r ) ranks=$OPTARG;;
    n ) nodes=$OPTARG;;
    p ) ppn=$OPTARG;;
    v ) verbose_lev=$OPTARG;;
    d ) debug_lev=$OPTARG;;
    b ) batch=1;;
    c ) chain=1;;
    a ) after=1;;
    m ) msub_arg=$OPTARG;;
   \? ) synexit "Error: invalid option";;
  esac
done
shift $((OPTIND - 1 ))
if [[ -n $1 ]]; then synexit "Error: extra parameters"; fi

# Figure out nodes, ranks and ppn
until [[ -n $nodes && -n $ranks && -n $ppn ]]; do
  # Two parm cases -- calc third parm
  if   [[ -n $nodes && -n $ranks ]]; then   ppn=$(( $ranks / $nodes ))   
  elif [[ -n $nodes && -n $ppn ]];   then ranks=$(( $nodes * $ppn   ))   
  elif [[ -n $ranks && -n $ppn ]];   then nodes=$(( $ranks / $ppn   ))
  # Nodes only specified, determine ppn and iterate
  elif [[ -n $nodes ]]; then
    if   [[ -n $PBS_NUM_PPN ]]; then ppn=$PBS_NUM_PPN
    elif [[ -n $SLURM_NTASKS_PER_NODE ]]; then ppn=$SLURM_NTASKS_PER_NODE
    elif [[ ${OSTYPE:0:6} == "darwin" ]]; then ppn=2
    else                                       ppn=2
    fi
  # Ranks only specified, determine nodes and iterate
  elif [[ -n ranks ]]; then
    if   [[ -n $PBS_NUM_NODES ]];         then nodes=$PBS_NUM_NODES
    elif [[ -n $SLURM_JOB_NUM_NODES ]];   then nodes=$SLURM_JOB_NUM_NODES
    elif [[ ${OSTYPE:0:6} == "darwin" ]]; then nodes=1
    elif [[ $ranks -eq 1 ]];              then nodes=1
    else                                       nodes=2
    fi
  # ppn only specified, determine nodes and iterate
  elif [[ -n ranks ]]; then
    if [[ ${OSTYPE:0:6} == "darwin" ]]; then nodes=1
    else                                     nodes=2
    fi 
  # Nothing specified, determine ranks and iterate
  else
    if   [[ -n $PBS_NP ]]; then                ranks=$PBS_NP
    elif [[ -n $SLURN_NPROCS ]]; then          ranks=$SLURM_NPROCS
    elif [[ ${OSTYPE:0:6} == "darwin" ]]; then ranks=2
    else                                       ranks=4
    fi
  fi
done  


if [[ $ranks -ne $(($nodes * $ppn)) ]]; then
  msg "ranks ($ranks) != nodes ($nodes) x ppn ($ppn)"
  exit
fi

# set some convenient constants
cons_ki=1024
cons_mi=$((1024*1024))
cons_gi=$((1024*1024*1024))

# Following commands for actually running, i.e., not batch submission
if [[ $batch -eq 0 ]]; then
  # Add .lib dir to library path
  build=${HIO_BUILD:=$PWD/..}
  libs=$build/src/.libs

  if   [[ ${OSTYPE:0:6} == "darwin" ]]; then export DYLD_LIBRARY_PATH=$libs:$DYLD_LIBRARY_PATH
  elif [[ ${OSTYPE:0:5} == "linux" ]];  then export LD_LIBRARY_PATH=$libs:$LD_LIBRARY_PATH
  else echo "run_setup: OSTYPE \"$OSTYPE\" not recognized"; exit; fi

  # Load module environment recorded at build
  mod_script="hiobuild.modules.bash"
  if [[ -e $HIO_BUILD/$mod_script ]]; then . $HIO_BUILD/$mod_script; fi 

  # If HIO_datawarp_root not set, set up manually allocated DW if needed
  # If not set, HIO will use $DW_JOB_STRIPED
  if [[ ${HOST:0:3} == "tt-" ]]; then
    # Late DW Ph 1 - location of manually allocated BB directory
    export HIO_datawarp_root="/tmp/dw_scr/$LOGNAME$job_dir"
  fi

  addifd() {
    if [[ -d $1 ]]; then HIO_TEST_ROOTS="$HIO_TEST_ROOTS,posix:$1/hio_test$job_dir"; fi
  }

  # If HIO_TEST_ROOTS not set, set up default
  if [[ -z $HIO_TEST_ROOTS ]]; then
    if [[ -n $DW_JOB_STRIPED ]]; then
      HIO_TEST_ROOTS="DataWarp"
    elif [[ ${HOSTNAME:0:3} == "tt-" ]]; then # Special for trinitite since Moab not integrated
      HIO_TEST_ROOTS="DataWarp"
    fi;
    addifd "/lscratch1/$LOGNAME"
    addifd "/lscratch2/$LOGNAME"
    addifd "/lscratch3/$LOGNAME"
    addifd "/lscratch4/$LOGNAME"
    addifd "/scratch1/users/$LOGNAME"
    addifd "/scratch2/users/$LOGNAME"
    addifd "/lustre/scratch4/users/$LOGNAME"
    addifd "/lustre/scratch5/users/$LOGNAME"
    addifd "/lustre/scratch1/yellow/$LOGNAME"
    addifd "$HOME/scratch-tmp"
    if [[ ${HIO_TEST_ROOTS:0:1} == "," ]]; then HIO_TEST_ROOTS=${HIO_TEST_ROOTS:1}; fi
  fi
  
  # Special hack for buffy - since no PFS, inhibit staging for sizes larger than tiny
  if [[ ${HOST:0:3} == "bu-" && $size != "t" ]]; then
    msg "Buffy with size > tiny, disabling datawarp staging"
    export HIO_datawarp_stage_mode="disable"
  fi

  # Display results of run_setup
  msg "run_setup:                    Args: \"$args\""
  msg "run_setup:                     PWD: \"$PWD\""
  msg "run_setup:                   build: \"$build\""
  msg "run_setup:                    libs: \"$libs\""
  msg "run_setup:          HIO_TEST_ROOTS: \"$HIO_TEST_ROOTS\""
  msg "run_setup:                  mpicmd: \"$mympicmd\""
  msg "run_setup:                    size: \"$size\""
  msg "run_setup:         nodes/ranks/ppn: $nodes / $ranks / $ppn"
  msg "run_setup:           verbose/debug: $verbose_lev / $debug_lev"
  msg "run_setup:       HIO_datawarp_root: \"$HIO_datawarp_root\""
  msg "run_setup: HIO_datawarp_stage_mode: \"$HIO_datawarp_stage_mode\""
fi

# --- end of run_setup ---
